SQL. Tworzenie, aktualizacja oraz usuwanie tabel. Wstawianie, aktualizacja i usuwanie danych z tabeli

Zadanie 1
Stwórz tabelę o nazwie pracownik i dodaj pola (kolumny) według wytycznych:
id_pracownika - klucz główny, liczba samozwiększająca się,
imie - ciąg znaków, pole wymagane, maksymalnie 40 znaków,
nazwisko - ciąg znaków, pole wymagane, maksymalnie 60 znaków,
data_urodzenia - typ daty, pole wymagane

CREATE TABLE pracownik (
    id_pracownika INT AUTO_INCREMENT PRIMARY KEY,
    imie VARCHAR(40) NOT NULL,
    nazwisko VARCHAR(60) NOT NULL,
    data_urodzenia DATE NOT NULL
);


Do tabeli pracownik wstaw 3 rekordy danych.

INSERT INTO pracownik (imie, nazwisko, data_urodzenia)
VALUES
('Imie1', 'Nazwisko1', '1985-03-10'),
('Imie2', 'Nazwisko2', '1992-07-21'),
('Imie3', 'Nazwisko3', '1978-11-05');


Zmodyfikuj wartość w kolumnie data_urodzenia dla dowolnego rekordu.

UPDATE pracownik
SET data_urodzenia = '1986-01-15'
WHERE id_pracownika = 1;
____________________________________________________________________________________________________________________
Zadanie 2
Stwórz tabelę zadanie z poniższymi polami:
id_zadania - klucz główny, liczba samozwiększająca się,
nazwa_zadania - ciąg znaków, pole wymagane, długość max. 150 znaków,
priorytet - typ wyliczeniowy (normalny, wysoki, niski),
opis - długi tekst, pole opcjonalne,
pracownik - klucz obcy do tabeli pracownik, w razie usunięcia wstaw null.

CREATE TABLE zadanie (
    id_zadania INT AUTO_INCREMENT PRIMARY KEY,
    nazwa_zadania VARCHAR(150) NOT NULL,
    priorytet ENUM('normalny', 'wysoki', 'niski'),
    opis TEXT,
    pracownik INT,
    CONSTRAINT fk_pracownik
        FOREIGN KEY (pracownik) REFERENCES pracownik(id_pracownika)
        ON DELETE SET NULL
);

Zmodyfikuj pole priorytet i ustaw wartość domyślną na normalny.

ALTER TABLE zadanie
    MODIFY priorytet ENUM('normalny', 'wysoki', 'niski') DEFAULT 'normalny';

Dodaj po jednym zadaniu dla każdego pracownika.


INSERT INTO zadanie (nazwa_zadania, priorytet, opis, pracownik)
VALUES
('zadanie1', 'normalny', 'opis1', 1),
('zadanie2', 'wysoki', 'opis2', 2),
('zadanie3', 'niski', NULL, 3);
____________________________________________________________________________________________________________________
Zadanie 3
Stwórz tabelę projekt z polami:
id_projektu - klucz glówny, liczba samozwiększająca się,
nazwa_projektu - ciąg znaków, max. 150 znaków,
data_rozpoczecia - typ daty,
data_zakonczenia - typ daty, może być pusty.
Za pomocą oddzielnego polecenia dodaj do tabeli projekt pole menadzer_projektu - klucz obcy do tabeli pracownik.

CREATE TABLE projekt (
    id_projektu INT AUTO_INCREMENT PRIMARY KEY,
    nazwa_projektu VARCHAR(150),
    data_rozpoczecia DATE,
    data_zakonczenia DATE NULL
);

ALTER TABLE projekt
ADD COLUMN menadzer_projektu INT,
ADD CONSTRAINT fk_menadzer_projektu
    FOREIGN KEY (menadzer_projektu) REFERENCES pracownik(id_pracownika);

Dodaj 2 rekordy do tabeli projekt.

INSERT INTO projekt (nazwa_projektu, data_rozpoczecia, data_zakonczenia, menadzer_projektu)
VALUES
('System raportowy', '2024-01-10', '2024-06-30', 1),
('Modernizacja infrastruktury', '2024-02-15', NULL, 2);

Dodaj do tabeli zadanie kolumnę projekt, klucz obcy do tabeli projekt, kaskadowe usuwanie rekordów.

ALTER TABLE zadanie
ADD COLUMN projekt INT,
ADD CONSTRAINT fk_zadanie_projekt
    FOREIGN KEY (projekt) REFERENCES projekt(id_projektu)
    ON DELETE CASCADE;

Zaktualizuj wartości w tabeli zadanie dodając brakujące identyfikatory projektu, do którego należy je przypisać.

UPDATE zadanie
SET projekt = 1
WHERE id_zadania IN (1, 2);

UPDATE zadanie
SET projekt = 2
WHERE id_zadania = 3;
____________________________________________________________________________________________________________________
Zadanie 4
Stwórz tabelę sprint z polami:
id_sprintu - klucz główny, liczba samozwiększająca się,
numer_sprintu - liczba całkowita nieujemna,
data_rozpoczecia - typ daty,
data_zakonczenia - typ daty.
Zmodyfikuj tabelę zadanie i dodaj kolumnę sprint, która będzie kluczem obcym do tabeli sprint, można wstawiać w niej wartość null (pole opcjonalne). Wstawiaj null w razie usunięcia rekordu nadrzędnego.

CREATE TABLE sprint (
    id_sprintu INT AUTO_INCREMENT PRIMARY KEY,
    numer_sprintu INT UNSIGNED,
    data_rozpoczecia DATE,
    data_zakonczenia DATE
);

ALTER TABLE zadanie
ADD COLUMN sprint INT NULL,
ADD CONSTRAINT fk_zadanie_sprint
    FOREIGN KEY (sprint) REFERENCES sprint(id_sprintu)
    ON DELETE SET NULL;

Dodaj 1 sprint i przydziel do niego 2 zadania.

INSERT INTO sprint (numer_sprintu, data_rozpoczecia, data_zakonczenia)
VALUES
(1, '2024-03-01', '2024-03-15');

UPDATE zadanie
SET sprint = 1
WHERE id_zadania IN (1, 2);
____________________________________________________________________________________________________________________
Zadanie 5
Stwórz tabelę status z polami:
id_statusu - klucz główny, liczba samozwiększająca się,
nazwa_statusu - ciąg znaków, max. 20 znaków.
Dodaj 3 różne statusy do tabeli status.

CREATE TABLE status (
    id_statusu INT AUTO_INCREMENT PRIMARY KEY,
    nazwa_statusu VARCHAR(20)
);

INSERT INTO status (nazwa_statusu)
VALUES
('Nowe'),
('W trakcie'),
('Zakończone');

Stwórz tabelę zadanie_has_status z polami:
id_zdarzenia - klucz główny, liczba samozwiększająca się,
id_zadania - klucz obcy do tabeli zadanie,
id_statusu - klucz obcy do tabeli status,
data_zdarzenia - typ daty i czasu, domyślnie CURRENT_TIMESTAMP.

CREATE TABLE zadanie_has_status (
    id_zdarzenia INT AUTO_INCREMENT PRIMARY KEY,
    id_zadania INT,
    id_statusu INT,
    data_zdarzenia DATETIME DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_zhs_zadanie
        FOREIGN KEY (id_zadania) REFERENCES zadanie(id_zadania)
        ON DELETE CASCADE,
    CONSTRAINT fk_zhs_status
        FOREIGN KEY (id_statusu) REFERENCES status(id_statusu)
);

Wstaw 3 rekordy do tabeli zadanie_has_status.

INSERT INTO zadanie_has_status (id_zadania, id_statusu)
VALUES
(1, 1),
(2, 2),
(3, 3);

Usuń z tabeli projekt jeden projekt i sprawdź czy powiązane rekordy w tabeli zadanie również zostały usunięte.

DELETE FROM projekt
WHERE id_projektu = 1;

SELECT * FROM zadanie;
____________________________________________________________________________________________________________________
SQL. Praca z kluczami głównymi i obcymi

Zadanie 1
Usuń klucze obce, które wskazują na pracownik.id_pracownika (w tabelach zadanie i projekt).

ALTER TABLE zadanie
DROP FOREIGN KEY fk_pracownik;

ALTER TABLE projekt
DROP FOREIGN KEY fk_menadzer_projektu;

Usuń klucz główny z tabeli pracownik.

ALTER TABLE pracownik
DROP PRIMARY KEY;

Dodaj ponownie klucz główny na kolumnie id_pracownika.

ALTER TABLE pracownik
ADD PRIMARY KEY (id_pracownika);

Odtwórz usunięte wcześniej klucze obce:
ON DELETE SET NULL w tabeli zadanie,
bez kaskadowego usuwania w tabeli projekt.

ALTER TABLE zadanie
ADD CONSTRAINT fk_pracownik
    FOREIGN KEY (pracownik) REFERENCES pracownik(id_pracownika)
    ON DELETE SET NULL;

ALTER TABLE projekt
ADD CONSTRAINT fk_menadzer_projektu
    FOREIGN KEY (menadzer_projektu) REFERENCES pracownik(id_pracownika);
____________________________________________________________________________________________________________________
Zadanie 2
Dodaj do tabeli zadanie nową kolumnę godziny_szacowane INTEGER z domyślną wartością 8.

ALTER TABLE zadanie
ADD COLUMN godziny_szacowane INT DEFAULT 8;

Ustaw różne wartości godziny_szacowane dla istniejących zadań (np. 4, 12, 16).

UPDATE zadanie SET godziny_szacowane = 4 WHERE id_zadania = 1;
UPDATE zadanie SET godziny_szacowane = 12 WHERE id_zadania = 2;
UPDATE zadanie SET godziny_szacowane = 16 WHERE id_zadania = 3;

Zmień domyślną wartość kolumny godziny_szacowane z 8 na 6.

ALTER TABLE zadanie
ALTER COLUMN godziny_szacowane SET DEFAULT 6;

Wstaw nowe zadanie (dowolne dane) i pokaż, że bez podania godziny_szacowane przyjmuje teraz wartość 6, następnie usuń to zadanie.

INSERT INTO zadanie (nazwa_zadania, priorytet, opis, pracownik, projekt, sprint)
VALUES ('Test default hours', 'normalny', NULL, NULL, NULL, NULL);

SELECT * FROM zadanie WHERE nazwa_zadania = 'Test default hours';

DELETE FROM zadanie
WHERE nazwa_zadania = 'Test default hours';
____________________________________________________________________________________________________________________
Zadanie 3
Dodaj do projekt kolumnę opis_projektu – ciąg znaków, max. 50 znaków (może być NULL).

ALTER TABLE projekt
ADD COLUMN opis_projektu VARCHAR(50) NULL;

Zmień typ tej kolumny na ciąg znaków, max. 200 znaków (rozszerzenie długości).

ALTER TABLE projekt
MODIFY opis_projektu VARCHAR(200) NULL;

Zaktualizuj kilka projektów, ustawiając w opis_projektu krótkie opisy (np. „MVP”, „pilne wdrożenie”).

UPDATE projekt SET opis_projektu = 'MVP' WHERE id_projektu = 1;
UPDATE projekt SET opis_projektu = 'pilne wdrożenie' WHERE id_projektu = 2;

Usuń kolumnę opis_projektu z tabeli projekt.

ALTER TABLE projekt
DROP COLUMN opis_projektu;
____________________________________________________________________________________________________________________
Zadanie 4
Usuń klucz obcy zadanie.projekt wskazujący na projekt.id_projektu.

ALTER TABLE zadanie
DROP FOREIGN KEY fk_zadanie_projekt;

Dodaj ponownie klucz obcy zadanie.projekt → projekt(id_projektu) z opcją ON DELETE SET NULL.

ALTER TABLE zadanie
ADD CONSTRAINT fk_zadanie_projekt
    FOREIGN KEY (projekt) REFERENCES projekt(id_projektu)
    ON DELETE SET NULL;

Usuń jeden wybrany projekt z tabeli projekt.

DELETE FROM projekt
WHERE id_projektu = 2;

Sprawdź (np. za pomocą SELECT), że zadania, które należały do usuniętego projektu, mają teraz w kolumnie projekt wartość NULL.

SELECT * FROM zadanie

WHERE projekt IS NULL;
____________________________________________________________________________________________________________________
#Zadanie 1
create table `ORDER` LIKE company_2025.ORDER;
INSERT INTO `ORDER` SELECT * from company_2025.ORDER;

CREATE TABLE CLIENT AS 
select * from company_2025.CLIENT;

CREATE TABLE EMPLOYEE AS 
select * from company_2025.EMPLOYEE;

select * from `ORDER`

select * from `ORDER` where ORDER_STATUS IN (5);

SELECT ORDER_ID, ORDER_STATUS
FROM `ORDER`
WHERE CLIENT_ID IN (1, 3, 5);

#Zadanie 2
select * from EMPLOYEE where FIRST_NAME like 'Agnieszka' and pensja = 3900

select * from EMPLOYEE WHERE pensja > 5000 and pensja < 7000
#between działa w trybie inclusive (wyłączając wartości brzegowe
select * from EMPLOYEE WHERE pensja between 5000 and 7000

SELECT * FROM company_2025.CLIENT
where SHORT_NAME LIKE '%eco%';
# % - dowolny ciąg znaków
# _ - dokładnie jeden znak	

select month(curdate());
... WHERE month(data) = 7;	
... WHERE month(data) IN (7,8);

#Zadanie 3
Select * from `ORDER`
where `ORDER_DATE` = 8;

Show create table `ORDER`

select * from company_2025.EMPLOYEE
order by BIRTH_DATE LIMIT 10,10;

#Zadanie 4 
# pkt 1 - distinct lub distinct()
select distinct first_name from company_2025.EMPLOYEE
select distinct (first_name) from company_2025.EMPLOYEE
#pkt 2 - concat()
select concat(first_name, ' - ', last_name) 
as 'imie i nazwisko' from company_2025.EMPLOYEE;
#pkt 3 -
#where date_of_employment between '2010-01-01' and ...
#where year(date_of_employment) between 2010 and 2014
#zadanie 5
Select * from CLIENT
where TAX_IDENTIFIER is NULL;
SHOW CREATE TABLE CLIENT

SELECT * FROM company_2025.CLIENT
where SHORT_NAME LIKE 'K%' OR SHORT_NAME LIKE '%ski'
ORDER BY SHORT_NAME DESC;
____________________________________________________________________________________________________________________
#SQL. Funkcje agregujące, grupowanie, łączenie tabel
#zadanie 1
#Wyświetl średnią pensję wszystkich pracowników.

SELECT AVG(pensja) AS srednia_pensja
FROM EMPLOYEE;

#Wyświetl średnią pensję oraz liczbę pracowników dla każdego stanowiska (JOB_POSITION_ID).

SELECT 
JOB_POSITION_ID
AVG(pensja) AS srednia_pensja,
COUNT(*) AS liczba_pracownikow
FROM EMPLOYEE
GROUP BY JOB_POSITION_ID

#Wyświetl średni wiek dla każdego departamentu (DEPARTMENT_ID), do którego należy pracownik.

SELECT 
departament_id,
AVG(YEAR(CURRENT_DATE) - YEAR(data_urodzenia)) AS sredni_wiek
FROM EMPLOYEE
GROUP BY departament_id;

#zadanie 2
#Dla każdego departamentu (DEPARTMENT_ID) wyświetl łączną pensję jego pracowników. Dane posortuj malejąco.

SELECT 
departament_id,
SUM(pensja) AS laczna_pensja
FROM EMPLOYEE
GROUP BY departament_id
ORDER BY laczna_pensja DESC;

#Dla każdego stanowiska pracy pracownika wyświetl średnią pensję, jeśli liczba pracowników na danym stanowisku jest ≥ 3 oraz średnia jest > 3000 PLN.

SELECT 
JOB_POSITION_ID
AVG(pensja) AS srednia_pensja,
COUNT(*) AS liczba_pracownikow
FROM EMPLOYEE
GROUP BY JOB_POSITION_ID
HAVING COUNT(*) >= 3
AND AVG(pensja) > 3000;

#Wyświetl, ile jest różnych pensji dla każdego departamentu,jeśli minimalna liczba pracowników departamentu jest > 4.Dane posortuj rosnąco według ilości różnych pensji.

SELECT 
DEPARTMENT_ID,
COUNT(DISTINCT pensja) AS distinct_salary_count,
COUNT(*) AS employee_count
FROM EMPLOYEE
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) > 4
ORDER BY distinct_salary_count ASC;

#zadanie 3
#Skopiuj tabele DEPARTMENT i JOB_POSITION z bazy company_2025 do swojej bazy danych.

CREATE TABLE DEPARTMENT AS
SELECT * FROM company_2025.DEPARTMENT;

CREATE TABLE JOB_POSITION AS
SELECT * FROM company_2025.JOB_POSITION;

#sposób z tablicą

select * from
EMPLOYEE E
INNER JOIN DEPARTMENT D on E.DEPARTMENT_ID=D.DEPARTMENT_ID;
#lub
select * from
EMPLOYEE E 
JOIN DEPARTMENT D on E.

#Wyświetl dla każdej nazwy departamentu liczbę jego pracowników.

SELECT d.DEPARTMENT_NAME AS nazwa_departamentu,
COUNT(e.EMPLOYEE_NAME) AS liczba_pracownikow
FROM DEPARTMENT d
LEFT JOIN EMPLOYEE e
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
GROUP BY d.DEPARTMENT_NAME;

#Wyświetl dla każdej nazwy departamentu imiona oraz nazwiska pracowników, którzy w nim pracują (łącznie).

SELECT 
d.DEPARTMENT_NAME AS nazwa_departamentu,
e.FIRST_NAME AS imie,
e.LAST_NAME AS nazwisko
FROM DEPARTMENT d
JOIN EMPLOYEE e
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
ORDER BY d.DEPARTMENT_NAME, e.LAST_NAME, e.FIRST_NAME;

#z użyciem group_concat()
SELECT 
D.DEPARTMENT_NAME,
GROUP_CONCAT(CONCAT(E.FIRST_NAME, ' ', E.LAST_NAME) SEPARATOR ', ') 
AS pracownicy
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME;

#zadanie 4
#Wyświetl nazwiska pracowników, którzy urodzili się w latach 90-tych XX wieku, oraz nazwy stanowisk, na których są zatrudnieni (użyj NATURAL JOIN, jeśli to możliwe).

SELECT 
LAST_NAME, JOB_POSITION_ID
FROM EMPLOYEE
NATURAL JOIN JOB_POSITION
WHERE BIRTH_DATE BETWEEN '1990-01-01' AND '1999-12-31';

#Wyświetl imiona i nazwiska 5 najmłodszych pracowników, którzy pracują jako „Magazynier”.

SELECT
FIRST_NAME, LAST_NAME, BIRTH_DATE
FROM EMPLOYEE
JOIN JOB_POSITION
ON EMPLOYEE.JOB_POSITION_ID = JOB_POSITION.JOB_POSITION_ID
WHERE POSITION_NAME = 'Magazynier'
ORDER BY BIRTH_DATE DESC
LIMIT 5; 

#Wypisz obok siebie skrócone nazwy klientów, których numer CLIENT_ID różni się o 5 (np. Kowalski - AutoMax, Nowak - Kaczmarek).

SELECT 
c1.SHORT_NAME AS klient_1,
c2.SHORT_NAME AS klient_2
FROM CLIENT c1
JOIN CLIENT c2
ON c1.CLIENT_ID = c2.CLIENT_ID + 5
ORDER BY c1.CLIENT_ID;

#Zadanie 5
#Dla każdego stanowiska pracy wyświetl średnie zarobki pracowników, jeśli pracownik nie pracuje w departamencie „IT” ani „HR” i liczba pracowników jest powyżej 3.

SELECT * FROM EMPLOYEE
JOIN JOB_POSITION j
JOIN DEPARTMENT d
WHERE d.DEPARTMENT_NAME NOT IN ('IT', 'HR')

#Dla każdego stanowiska pracownika wyświetl: imię, nazwisko, datę urodzenia najmłodszej i najstarszej osoby, oraz departament, w którym pracują.
