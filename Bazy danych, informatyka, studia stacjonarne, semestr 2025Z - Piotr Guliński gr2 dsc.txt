SQL. Tworzenie, aktualizacja oraz usuwanie tabel. Wstawianie, aktualizacja i usuwanie danych z tabeli

Zadanie 1
Stwórz tabelę o nazwie pracownik i dodaj pola (kolumny) według wytycznych:
id_pracownika - klucz główny, liczba samozwiększająca się,
imie - ciąg znaków, pole wymagane, maksymalnie 40 znaków,
nazwisko - ciąg znaków, pole wymagane, maksymalnie 60 znaków,
data_urodzenia - typ daty, pole wymagane

CREATE TABLE pracownik (
    id_pracownika INT AUTO_INCREMENT PRIMARY KEY,
    imie VARCHAR(40) NOT NULL,
    nazwisko VARCHAR(60) NOT NULL,
    data_urodzenia DATE NOT NULL
);


Do tabeli pracownik wstaw 3 rekordy danych.

INSERT INTO pracownik (imie, nazwisko, data_urodzenia)
VALUES
('Imie1', 'Nazwisko1', '1985-03-10'),
('Imie2', 'Nazwisko2', '1992-07-21'),
('Imie3', 'Nazwisko3', '1978-11-05');


Zmodyfikuj wartość w kolumnie data_urodzenia dla dowolnego rekordu.

UPDATE pracownik
SET data_urodzenia = '1986-01-15'
WHERE id_pracownika = 1;
____________________________________________________________________________________________________________________
Zadanie 2
Stwórz tabelę zadanie z poniższymi polami:
id_zadania - klucz główny, liczba samozwiększająca się,
nazwa_zadania - ciąg znaków, pole wymagane, długość max. 150 znaków,
priorytet - typ wyliczeniowy (normalny, wysoki, niski),
opis - długi tekst, pole opcjonalne,
pracownik - klucz obcy do tabeli pracownik, w razie usunięcia wstaw null.

CREATE TABLE zadanie (
    id_zadania INT AUTO_INCREMENT PRIMARY KEY,
    nazwa_zadania VARCHAR(150) NOT NULL,
    priorytet ENUM('normalny', 'wysoki', 'niski'),
    opis TEXT,
    pracownik INT,
    CONSTRAINT fk_pracownik
        FOREIGN KEY (pracownik) REFERENCES pracownik(id_pracownika)
        ON DELETE SET NULL
);

Zmodyfikuj pole priorytet i ustaw wartość domyślną na normalny.

ALTER TABLE zadanie
    MODIFY priorytet ENUM('normalny', 'wysoki', 'niski') DEFAULT 'normalny';

Dodaj po jednym zadaniu dla każdego pracownika.


INSERT INTO zadanie (nazwa_zadania, priorytet, opis, pracownik)
VALUES
('zadanie1', 'normalny', 'opis1', 1),
('zadanie2', 'wysoki', 'opis2', 2),
('zadanie3', 'niski', NULL, 3);
____________________________________________________________________________________________________________________
Zadanie 3
Stwórz tabelę projekt z polami:
id_projektu - klucz glówny, liczba samozwiększająca się,
nazwa_projektu - ciąg znaków, max. 150 znaków,
data_rozpoczecia - typ daty,
data_zakonczenia - typ daty, może być pusty.
Za pomocą oddzielnego polecenia dodaj do tabeli projekt pole menadzer_projektu - klucz obcy do tabeli pracownik.

CREATE TABLE projekt (
    id_projektu INT AUTO_INCREMENT PRIMARY KEY,
    nazwa_projektu VARCHAR(150),
    data_rozpoczecia DATE,
    data_zakonczenia DATE NULL
);

ALTER TABLE projekt
ADD COLUMN menadzer_projektu INT,
ADD CONSTRAINT fk_menadzer_projektu
    FOREIGN KEY (menadzer_projektu) REFERENCES pracownik(id_pracownika);

Dodaj 2 rekordy do tabeli projekt.

INSERT INTO projekt (nazwa_projektu, data_rozpoczecia, data_zakonczenia, menadzer_projektu)
VALUES
('System raportowy', '2024-01-10', '2024-06-30', 1),
('Modernizacja infrastruktury', '2024-02-15', NULL, 2);

Dodaj do tabeli zadanie kolumnę projekt, klucz obcy do tabeli projekt, kaskadowe usuwanie rekordów.

ALTER TABLE zadanie
ADD COLUMN projekt INT,
ADD CONSTRAINT fk_zadanie_projekt
    FOREIGN KEY (projekt) REFERENCES projekt(id_projektu)
    ON DELETE CASCADE;

Zaktualizuj wartości w tabeli zadanie dodając brakujące identyfikatory projektu, do którego należy je przypisać.

UPDATE zadanie
SET projekt = 1
WHERE id_zadania IN (1, 2);

UPDATE zadanie
SET projekt = 2
WHERE id_zadania = 3;
____________________________________________________________________________________________________________________
Zadanie 4
Stwórz tabelę sprint z polami:
id_sprintu - klucz główny, liczba samozwiększająca się,
numer_sprintu - liczba całkowita nieujemna,
data_rozpoczecia - typ daty,
data_zakonczenia - typ daty.
Zmodyfikuj tabelę zadanie i dodaj kolumnę sprint, która będzie kluczem obcym do tabeli sprint, można wstawiać w niej wartość null (pole opcjonalne). Wstawiaj null w razie usunięcia rekordu nadrzędnego.

CREATE TABLE sprint (
    id_sprintu INT AUTO_INCREMENT PRIMARY KEY,
    numer_sprintu INT UNSIGNED,
    data_rozpoczecia DATE,
    data_zakonczenia DATE
);

ALTER TABLE zadanie
ADD COLUMN sprint INT NULL,
ADD CONSTRAINT fk_zadanie_sprint
    FOREIGN KEY (sprint) REFERENCES sprint(id_sprintu)
    ON DELETE SET NULL;

Dodaj 1 sprint i przydziel do niego 2 zadania.

INSERT INTO sprint (numer_sprintu, data_rozpoczecia, data_zakonczenia)
VALUES
(1, '2024-03-01', '2024-03-15');

UPDATE zadanie
SET sprint = 1
WHERE id_zadania IN (1, 2);
____________________________________________________________________________________________________________________
Zadanie 5
Stwórz tabelę status z polami:
id_statusu - klucz główny, liczba samozwiększająca się,
nazwa_statusu - ciąg znaków, max. 20 znaków.
Dodaj 3 różne statusy do tabeli status.

CREATE TABLE status (
    id_statusu INT AUTO_INCREMENT PRIMARY KEY,
    nazwa_statusu VARCHAR(20)
);

INSERT INTO status (nazwa_statusu)
VALUES
('Nowe'),
('W trakcie'),
('Zakończone');

Stwórz tabelę zadanie_has_status z polami:
id_zdarzenia - klucz główny, liczba samozwiększająca się,
id_zadania - klucz obcy do tabeli zadanie,
id_statusu - klucz obcy do tabeli status,
data_zdarzenia - typ daty i czasu, domyślnie CURRENT_TIMESTAMP.

CREATE TABLE zadanie_has_status (
    id_zdarzenia INT AUTO_INCREMENT PRIMARY KEY,
    id_zadania INT,
    id_statusu INT,
    data_zdarzenia DATETIME DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_zhs_zadanie
        FOREIGN KEY (id_zadania) REFERENCES zadanie(id_zadania)
        ON DELETE CASCADE,
    CONSTRAINT fk_zhs_status
        FOREIGN KEY (id_statusu) REFERENCES status(id_statusu)
);

Wstaw 3 rekordy do tabeli zadanie_has_status.

INSERT INTO zadanie_has_status (id_zadania, id_statusu)
VALUES
(1, 1),
(2, 2),
(3, 3);

Usuń z tabeli projekt jeden projekt i sprawdź czy powiązane rekordy w tabeli zadanie również zostały usunięte.

DELETE FROM projekt
WHERE id_projektu = 1;

SELECT * FROM zadanie;
____________________________________________________________________________________________________________________
SQL. Praca z kluczami głównymi i obcymi

Zadanie 1
Usuń klucze obce, które wskazują na pracownik.id_pracownika (w tabelach zadanie i projekt).

ALTER TABLE zadanie
DROP FOREIGN KEY fk_pracownik;

ALTER TABLE projekt
DROP FOREIGN KEY fk_menadzer_projektu;

Usuń klucz główny z tabeli pracownik.

ALTER TABLE pracownik
DROP PRIMARY KEY;

Dodaj ponownie klucz główny na kolumnie id_pracownika.

ALTER TABLE pracownik
ADD PRIMARY KEY (id_pracownika);

Odtwórz usunięte wcześniej klucze obce:
ON DELETE SET NULL w tabeli zadanie,
bez kaskadowego usuwania w tabeli projekt.

ALTER TABLE zadanie
ADD CONSTRAINT fk_pracownik
    FOREIGN KEY (pracownik) REFERENCES pracownik(id_pracownika)
    ON DELETE SET NULL;

ALTER TABLE projekt
ADD CONSTRAINT fk_menadzer_projektu
    FOREIGN KEY (menadzer_projektu) REFERENCES pracownik(id_pracownika);
____________________________________________________________________________________________________________________
Zadanie 2
Dodaj do tabeli zadanie nową kolumnę godziny_szacowane INTEGER z domyślną wartością 8.

ALTER TABLE zadanie
ADD COLUMN godziny_szacowane INT DEFAULT 8;

Ustaw różne wartości godziny_szacowane dla istniejących zadań (np. 4, 12, 16).

UPDATE zadanie SET godziny_szacowane = 4 WHERE id_zadania = 1;
UPDATE zadanie SET godziny_szacowane = 12 WHERE id_zadania = 2;
UPDATE zadanie SET godziny_szacowane = 16 WHERE id_zadania = 3;

Zmień domyślną wartość kolumny godziny_szacowane z 8 na 6.

ALTER TABLE zadanie
ALTER COLUMN godziny_szacowane SET DEFAULT 6;

Wstaw nowe zadanie (dowolne dane) i pokaż, że bez podania godziny_szacowane przyjmuje teraz wartość 6, następnie usuń to zadanie.

INSERT INTO zadanie (nazwa_zadania, priorytet, opis, pracownik, projekt, sprint)
VALUES ('Test default hours', 'normalny', NULL, NULL, NULL, NULL);

SELECT * FROM zadanie WHERE nazwa_zadania = 'Test default hours';

DELETE FROM zadanie
WHERE nazwa_zadania = 'Test default hours';

Zadanie 3
Dodaj do projekt kolumnę opis_projektu – ciąg znaków, max. 50 znaków (może być NULL).

ALTER TABLE projekt
ADD COLUMN opis_projektu VARCHAR(50) NULL;

Zmień typ tej kolumny na ciąg znaków, max. 200 znaków (rozszerzenie długości).

ALTER TABLE projekt
MODIFY opis_projektu VARCHAR(200) NULL;

Zaktualizuj kilka projektów, ustawiając w opis_projektu krótkie opisy (np. „MVP”, „pilne wdrożenie”).

UPDATE projekt SET opis_projektu = 'MVP' WHERE id_projektu = 1;
UPDATE projekt SET opis_projektu = 'pilne wdrożenie' WHERE id_projektu = 2;

Usuń kolumnę opis_projektu z tabeli projekt.

ALTER TABLE projekt
DROP COLUMN opis_projektu;

Zadanie 4
Usuń klucz obcy zadanie.projekt wskazujący na projekt.id_projektu.

ALTER TABLE zadanie
DROP FOREIGN KEY fk_zadanie_projekt;

Dodaj ponownie klucz obcy zadanie.projekt → projekt(id_projektu) z opcją ON DELETE SET NULL.

ALTER TABLE zadanie
ADD CONSTRAINT fk_zadanie_projekt
    FOREIGN KEY (projekt) REFERENCES projekt(id_projektu)
    ON DELETE SET NULL;

Usuń jeden wybrany projekt z tabeli projekt.

DELETE FROM projekt
WHERE id_projektu = 2;

Sprawdź (np. za pomocą SELECT), że zadania, które należały do usuniętego projektu, mają teraz w kolumnie projekt wartość NULL.

SELECT * FROM zadanie

WHERE projekt IS NULL;
____________________________________________________________________________________________________________________
#Zadanie 1
create table `ORDER` LIKE company_2025.ORDER;
INSERT INTO `ORDER` SELECT * from company_2025.ORDER;

CREATE TABLE CLIENT AS 
select * from company_2025.CLIENT;

CREATE TABLE EMPLOYEE AS 
select * from company_2025.EMPLOYEE;

select * from `ORDER`

select * from `ORDER` where ORDER_STATUS IN (5);

SELECT ORDER_ID, ORDER_STATUS
FROM `ORDER`
WHERE CLIENT_ID IN (1, 3, 5);

#Zadanie 2
select * from EMPLOYEE where FIRST_NAME like 'Agnieszka' and pensja = 3900

select * from EMPLOYEE WHERE pensja > 5000 and pensja < 7000
#between działa w trybie inclusive (wyłączając wartości brzegowe
select * from EMPLOYEE WHERE pensja between 5000 and 7000

SELECT * FROM company_2025.CLIENT
where SHORT_NAME LIKE '%eco%';
# % - dowolny ciąg znaków
# _ - dokładnie jeden znak	

select month(curdate());
... WHERE month(data) = 7;	
... WHERE month(data) IN (7,8);

#Zadanie 3
Select * from `ORDER`
where `ORDER_DATE` = 8;

Show create table `ORDER`

select * from company_2025.EMPLOYEE
order by BIRTH_DATE LIMIT 10,10;

#Zadanie 4 
# pkt 1 - distinct lub distinct()
select distinct first_name from company_2025.EMPLOYEE
select distinct (first_name) from company_2025.EMPLOYEE
#pkt 2 - concat()
select concat(first_name, ' - ', last_name) 
as 'imie i nazwisko' from company_2025.EMPLOYEE;
#pkt 3 -
#where date_of_employment between '2010-01-01' and ...
#where year(date_of_employment) between 2010 and 2014
#zadanie 5
Select * from CLIENT
where TAX_IDENTIFIER is NULL;
SHOW CREATE TABLE CLIENT

SELECT * FROM company_2025.CLIENT
where SHORT_NAME LIKE 'K%' OR SHORT_NAME LIKE '%ski'
ORDER BY SHORT_NAME DESC;
____________________________________________________________________________________________________________________
#SQL. Funkcje agregujące, grupowanie, łączenie tabel
#zadanie 1
#Wyświetl średnią pensję wszystkich pracowników.

SELECT AVG(pensja) AS srednia_pensja
FROM EMPLOYEE;

#Wyświetl średnią pensję oraz liczbę pracowników dla każdego stanowiska (JOB_POSITION_ID).

SELECT 
JOB_POSITION_ID
AVG(pensja) AS srednia_pensja,
COUNT(*) AS liczba_pracownikow
FROM EMPLOYEE
GROUP BY JOB_POSITION_ID

#Wyświetl średni wiek dla każdego departamentu (DEPARTMENT_ID), do którego należy pracownik.

SELECT 
departament_id,
AVG(YEAR(CURRENT_DATE) - YEAR(data_urodzenia)) AS sredni_wiek
FROM EMPLOYEE
GROUP BY departament_id;

#zadanie 2
#Dla każdego departamentu (DEPARTMENT_ID) wyświetl łączną pensję jego pracowników. Dane posortuj malejąco.

SELECT 
departament_id,
SUM(pensja) AS laczna_pensja
FROM EMPLOYEE
GROUP BY departament_id
ORDER BY laczna_pensja DESC;

#Dla każdego stanowiska pracy pracownika wyświetl średnią pensję, jeśli liczba pracowników na danym stanowisku jest ≥ 3 oraz średnia jest > 3000 PLN.

SELECT 
JOB_POSITION_ID
AVG(pensja) AS srednia_pensja,
COUNT(*) AS liczba_pracownikow
FROM EMPLOYEE
GROUP BY JOB_POSITION_ID
HAVING COUNT(*) >= 3
AND AVG(pensja) > 3000;

#Wyświetl, ile jest różnych pensji dla każdego departamentu,jeśli minimalna liczba pracowników departamentu jest > 4.Dane posortuj rosnąco według ilości różnych pensji.

SELECT 
DEPARTMENT_ID,
COUNT(DISTINCT pensja) AS distinct_salary_count,
COUNT(*) AS employee_count
FROM EMPLOYEE
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) > 4
ORDER BY distinct_salary_count ASC;

#zadanie 3
#Skopiuj tabele DEPARTMENT i JOB_POSITION z bazy company_2025 do swojej bazy danych.

CREATE TABLE DEPARTMENT AS
SELECT * FROM company_2025.DEPARTMENT;

CREATE TABLE JOB_POSITION AS
SELECT * FROM company_2025.JOB_POSITION;

#sposób z tablicą

select * from
EMPLOYEE E
INNER JOIN DEPARTMENT D on E.DEPARTMENT_ID=D.DEPARTMENT_ID;
#lub
select * from
EMPLOYEE E 
JOIN DEPARTMENT D on E.

#Wyświetl dla każdej nazwy departamentu liczbę jego pracowników.

SELECT d.DEPARTMENT_NAME AS nazwa_departamentu,
COUNT(e.EMPLOYEE_NAME) AS liczba_pracownikow
FROM DEPARTMENT d
LEFT JOIN EMPLOYEE e
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
GROUP BY d.DEPARTMENT_NAME;

#Wyświetl dla każdej nazwy departamentu imiona oraz nazwiska pracowników, którzy w nim pracują (łącznie).

SELECT 
d.DEPARTMENT_NAME AS nazwa_departamentu,
e.FIRST_NAME AS imie,
e.LAST_NAME AS nazwisko
FROM DEPARTMENT d
JOIN EMPLOYEE e
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
ORDER BY d.DEPARTMENT_NAME, e.LAST_NAME, e.FIRST_NAME;

#z użyciem group_concat()
SELECT 
D.DEPARTMENT_NAME,
GROUP_CONCAT(CONCAT(E.FIRST_NAME, ' ', E.LAST_NAME) SEPARATOR ', ') 
AS pracownicy
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME;

#zadanie 4
#Wyświetl nazwiska pracowników, którzy urodzili się w latach 90-tych XX wieku, oraz nazwy stanowisk, na których są zatrudnieni (użyj NATURAL JOIN, jeśli to możliwe).

SELECT 
LAST_NAME, JOB_POSITION_ID
FROM EMPLOYEE
NATURAL JOIN JOB_POSITION
WHERE BIRTH_DATE BETWEEN '1990-01-01' AND '1999-12-31';

#Wyświetl imiona i nazwiska 5 najmłodszych pracowników, którzy pracują jako „Magazynier”.

SELECT
FIRST_NAME, LAST_NAME, BIRTH_DATE
FROM EMPLOYEE
JOIN JOB_POSITION
ON EMPLOYEE.JOB_POSITION_ID = JOB_POSITION.JOB_POSITION_ID
WHERE POSITION_NAME = 'Magazynier'
ORDER BY BIRTH_DATE DESC
LIMIT 5; 

#Wypisz obok siebie skrócone nazwy klientów, których numer CLIENT_ID różni się o 5 (np. Kowalski - AutoMax, Nowak - Kaczmarek).

SELECT 
c1.SHORT_NAME AS klient_1,
c2.SHORT_NAME AS klient_2
FROM CLIENT c1
JOIN CLIENT c2
ON c1.CLIENT_ID = c2.CLIENT_ID + 5
ORDER BY c1.CLIENT_ID;

#Zadanie 5
#Dla każdego stanowiska pracy wyświetl średnie zarobki pracowników, jeśli pracownik nie pracuje w departamencie „IT” ani „HR” i liczba pracowników jest powyżej 3.

SELECT * FROM EMPLOYEE
JOIN JOB_POSITION j
JOIN DEPARTMENT d
WHERE d.DEPARTMENT_NAME NOT IN ('IT', 'HR')

#Dla każdego stanowiska pracownika wyświetl: imię, nazwisko, datę urodzenia najmłodszej i najstarszej osoby, oraz departament, w którym pracują.

____________________________________________________________________________________________________________________
#SQL. Złączanie tabel, podzapytania oraz wybrane funkcje wbudowane MySQL
#Zadanie 1
#Wyświetl dane klientów, którzy nie złożyli żadnego zamówienia. Wykonaj zadanie na dwa sposoby - patrz podpowiedź.

SELECT c.*
FROM company_2025.CLIENT c
LEFT JOIN company_2025.`ORDER` o
ON o.CLIENT_ID = c.CLIENT_ID
WHERE o.CLIENT_ID IS NULL;

SELECT *
FROM company_2025.CLIENT
WHERE CLIENT_ID NOT IN (
SELECT DISTINCT CLIENT_ID
FROM company_2025.`ORDER`);

#Wyświetl nazwy jednostek miary (UNIT_NAME), które nie zostały wykorzystane w tabeli INVENTORY. Wykorzystaj do tego celu RIGHT JOIN.

SELECT u.UNIT_NAME
FROM company_2025.INVENTORY i
RIGHT JOIN company_2025.UNIT_OF_MEASUREMENT u
ON u.UNIT_ID = i.UNIT_ID
WHERE i.UNIT_ID IS NULL;

#Wylicz średnią różnicę między ceną zakupu a ceną sprzedaży każdego sprzedanego produktu i wyświetl nazwy tych produktów oraz tę wyliczoną różnicę. Dane posortuj po różnicy malejąco.

SELECT
p.PRODUCT_NAME,
AVG(op.SELL_PRICE - p.PURCHASE_PRICE) AS avg_price_diff
FROM company_2025.ORDER_POSITION op
JOIN company_2025.PRODUCT p
ON p.PRODUCT_ID = op.PRODUCT_ID
GROUP BY p.PRODUCT_ID, p.PRODUCT_NAME
ORDER BY avg_price_diff DESC;

#Zadanie 2
#Wyświetl unikalną listę nazw departamentów, w których pracują pracownicy, którzy wystawili zamówienia.

SELECT DISTINCT d.DEPARTMENT_NAME
FROM company_2025.DEPARTMENT d
JOIN company_2025.EMPLOYEE e
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN company_2025.`ORDER` o
ON o.EMPLOYEE_ID = e.EMPLOYEE_NAME;
    
#Zsumuj wartość zamówień dla każdego departamentu. Wyświetlaj dane w postaci nazwy departamentu oraz łącznej wartości zamówień.

SELECT
d.DEPARTMENT_NAME,
SUM(op.AMOUNT * op.SELL_PRICE) AS total_order_value
FROM company_2025.DEPARTMENT d
JOIN company_2025.EMPLOYEE e
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN company_2025.`ORDER` o
ON o.EMPLOYEE_ID = e.EMPLOYEE_NAME
JOIN company_2025.ORDER_POSITION op
ON op.ORDER_ID = o.ORDER_ID
GROUP BY d.DEPARTMENT_NAME;

#Do zadania numer 2 (jako drugą kolumnę) dodaj jeszcze podsumę dla każdego statusu (wyświetlaj jego nazwę, a nie identyfikator).

ELECT
d.DEPARTMENT_NAME,
s.STATUS_NAME,
SUM(op.AMOUNT * op.SELL_PRICE) AS total_order_value
FROM company_2025.DEPARTMENT d
JOIN company_2025.EMPLOYEE e
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
JOIN company_2025.`ORDER` o
ON o.EMPLOYEE_ID = e.EMPLOYEE_NAME
JOIN company_2025.ORDER_POSITION op
ON op.ORDER_ID = o.ORDER_ID
JOIN company_2025.ORDER_STATUS s
ON s.STATUS_ID = o.ORDER_STATUS
GROUP BY d.DEPARTMENT_NAME, s.STATUS_NAME
ORDER BY d.DEPARTMENT_NAME, s.STATUS_NAME;

#Zadanie 3
#Wykorzystując wbudowaną funkcję CONCAT wyświetl pełne nazwy produktów w formacie: Nazwa produktu (Opis produktu). Patrz przykładowe wyniki poniżej.

SELECT
CONCAT(PRODUCT_NAME, ' (', DESCRIPTION, ')') AS full_product_name
FROM company_2025.PRODUCT;

#Wykorzystując wbudowaną funkcję CONCAT_WS wyświetl wszystkie kolumny z tabeli PRODUCT oddzielając wartości przecinkiem.

SELECT
CONCAT_WS(', ',
PRODUCT_ID,
CATEGORY_ID,
PRODUCT_NAME,
PURCHASE_PRICE,
DESCRIPTION) AS product_row
FROM company_2025.PRODUCT;

#Wykorzystując wbudowaną funkcję CONCAT oraz GROUP_CONCAT wyświetl dla każdego działu listę pracowników (imię i nazwisko) pracujących w danym dziale.

SELECT
d.DEPARTMENT_NAME,
GROUP_CONCAT(
CONCAT(e.FIRST_NAME, ' ', e.LAST_NAME)
ORDER BY e.LAST_NAME, e.FIRST_NAME
SEPARATOR ', '
) AS employees
FROM company_2025.DEPARTMENT d
JOIN company_2025.EMPLOYEE e
ON e.DEPARTMENT_ID = d.DEPARTMENT_ID
GROUP BY d.DEPARTMENT_ID, d.DEPARTMENT_NAME;

#Wykorzystując wbudowaną funkcję GROUP_CONCAT wyświetl nazwę kategorii, a w kolejnej kolumnie listę nazw produktów z tej kategorii, które nigdy nie były sprzedane.

SELECT
c.CATEGORY_NAME,
GROUP_CONCAT(
p.PRODUCT_NAME
ORDER BY p.PRODUCT_NAME
SEPARATOR ', '
) AS unsold_products
FROM company_2025.CATEGORY c
JOIN company_2025.PRODUCT p
   ON p.CATEGORY_ID = c.CATEGORY_ID
LEFT JOIN company_2025.ORDER_POSITION op
ON op.PRODUCT_ID = p.PRODUCT_ID
WHERE op.PRODUCT_ID IS NULL
GROUP BY c.CATEGORY_ID, c.CATEGORY_NAME;

#Zadanie 4
#Wyświetl numer zamówienia oraz w kolejnej kolumnie tekst Zakończone, jeśli status zamówienia to 3,4,7 lub 10, w przeciwnym wypadku wyświetlaj tekst Inny.

SELECT
o.ORDER_NUMBER,
IF(o.ORDER_STATUS IN (3,4,7,10), 'Zakończone', 'Inny') AS status_text
FROM company_2025.`ORDER` o;

#Wyświetl nazwę produktu, a w następnej kolumnie o nazwię dostepnosc wyświetl tekst w zależności od ilości dostępnej w magazynie (INVENTORY.AMOUNT):
#Brak - jeśli ilość jest równa 0
#Mała ilość - jeśli ilość jest większa niż 0, ale mniejsza niż 10
#Średnia ilość - jeśli ilość jest większa niż 9, ale mniejsza lub równa 30
#Duża ilość - jeśli ilość jest większa niż 30

SELECT
p.PRODUCT_NAME,
CASE
WHEN i.AMOUNT = 0 THEN 'Brak'
WHEN i.AMOUNT > 0 AND i.AMOUNT < 10 THEN 'Mała ilość'
WHEN i.AMOUNT > 9 AND i.AMOUNT <= 30 THEN 'Średnia ilość'
ELSE 'Duża ilość'
END AS dostepnosc
FROM company_2025.PRODUCT p
JOIN company_2025.INVENTORY i
ON i.PRODUCT_ID = p.PRODUCT_ID;
    
#Wykorzystując funkcję IFNULL wyświetl wartość z kolumny TAX_IDENTIFIER z tabeli CLIENT jeżeli nie jest pusta lub tekst Klient indywidualny w przeciwnym wypadku.

SELECT
SHORT_NAME,
IFNULL(TAX_IDENTIFIER, 'Klient indywidualny') AS tax_or_info
FROM company_2025.CLIENT;

#Zadanie 5
#Wyświetl wartość z kolumny CITY, a następnie w kolejnej kolumnie 2 pierwsze znaki z kolumny POSTAL_CODE w tabeli CLIENT_ADDRESS.

SELECT
CITY,
SUBSTR(POSTAL_CODE, 1, 2) AS postal_prefix
FROM company_2025.CLIENT_ADDRESS;

#inna metoda

SELECT substr(STREET, position(' ' in STREET) + 1)
from CLIENT_ADRESS;

SELECT STREET,
position(' ' in reverse(STREET)) from CLIENT_ADRESS;

#Wykorzystując zapytanie z zadania 1, wyświetl nazwę miasta, a następnie w kolejnej kolumnie unikalne 2 pierwsze znaki z kodów dla tego miasta (patrz podpowiedź).

SELECT
CITY,
GROUP_CONCAT(
DISTINCT SUBSTR(POSTAL_CODE, 1, 2)	ORDER BY SUBSTR(POSTAL_CODE, 1, 2)
SEPARATOR ', ') AS postal_prefixes
FROM company_2025.CLIENT_ADDRESS
GROUP BY CITY;

____________________________________________________________________________________________________________________
SQL. Funkcje tekstowe, daty i czasu MySQL
#Zadanie 1
#Pełna nazwa klienta, nazwa ulicy, długość i pierwsze 5 liter ulicy.
SELECT
c.FULL_NAME,
ca.STREET,
LENGTH(ca.STREET) AS street_length,
SUBSTR(ca.STREET, 5, 5) as street_first5
FROM company_2025.CLIENT c
JOIN company_2025.CLIENT_ADDRESS ca
ON ca.CLIENT_ID = c.CLIENT_ID;

#Skrócona nazwa klienta i nazwa typu adresu (z uwzględnieniem klientów bez przypisanego typu adresu).
SELECT
c.SHORT_NAME,
ca.ADDRESS_TYPE
FROM company_2025.CLIENT c
LEFT JOIN company_2025.CLIENT_ADDRESS ca
ON ca.CLIENT_ID = c.CLIENT_ID;


#Nazwa produktu, nazwa kategorii, pierwsze trzy znaki nazwy produktu.
SELECT
p.PRODUCT_NAME,
c.CATEGORY_NAME,
SUBSTR(p.PRODUCT_NAME, 1, 3) AS product_first3
FROM company_2025.PRODUCT p
JOIN company_2025.CATEGORY c
ON c.CATEGORY_ID = p.CATEGORY_ID;

#Nazwy produktów i opisy tych, które zostały sprzedane.
SELECT DISTINCT
p.PRODUCT_NAME,
p.DESCRIPTION
FROM company_2025.PRODUCT p
JOIN company_2025.ORDER_POSITION op
ON op.PRODUCT_ID = p.PRODUCT_ID;
    
#Zadanie 2
#Nazwa klienta, numer i data zamówienia oraz dni które upłynęły od daty zamówienia.
SELECT
c.FULL_NAME,
o.ORDER_NUMBER,
o.ORDER_DATE,
DATEDIFF(CURDATE(), o.ORDER_DATE) AS dni_od_zamowienia
FROM company_2025.`ORDER` o
JOIN company_2025.CLIENT c
ON c.CLIENT_ID = o.CLIENT_ID;

#Dla wszystkich zamówień które nie mają statusu Zwrocone albo Zamkniete. Oblicz i wyświetl termin płatności który wynosi 14 dni od daty zamówienia.

SELECT
o.ORDER_ID,
o.ORDER_DATE,
DATE_ADD(o.ORDER_DATE, INTERVAL 14 DAY) AS due_date
FROM company_2025.`ORDER` o
JOIN company_2025.ORDER_STATUS s
ON s.STATUS_ID = o.ORDER_STATUS
WHERE s.STATUS_NAME NOT IN ('Zwrocone', 'Zamkniete');

#Imię, nazwisko, data zatrudnienia, dzień tygodnia i nazwa działu (również pracownicy bez działu).

SELECT
e.FIRST_NAME,
e.LAST_NAME,
e.DATE_OF_EMPLOYMENT,
DAYNAME(e.DATE_OF_EMPLOYMENT) AS dzien_tygodnia,
d.DEPARTMENT_NAME
FROM company_2025.EMPLOYEE e
LEFT JOIN company_2025.DEPARTMENT d
ON d.DEPARTMENT_ID = e.DEPARTMENT_ID;
    
#Różnica dni pomiędzy najwcześniejszym, a najpóźniejszym zamówieniem klienta, także dla klientów bez zamówień.

SELECT
c.FULL_NAME,
DATEDIFF(MAX(o.ORDER_DATE), MIN(o.ORDER_DATE)) AS dni_pomiedzy
FROM company_2025.CLIENT c
LEFT JOIN company_2025.`ORDER` o
ON o.CLIENT_ID = c.CLIENT_ID
GROUP BY c.CLIENT_ID, c.FULL_NAME;

#Zadanie 3
#Skrócona nazwa klienta oraz lista adresów oddzielona przecinkami.

SELECT
c.SHORT_NAME,
GROUP_CONCAT(
CONCAT(ca.STREET, ', ', ca.POSTAL_CODE, ' ', ca.CITY)
ORDER BY ca.CITY, ca.POSTAL_CODE, ca.STREET
SEPARATOR ', '
) AS addresses
FROM company_2025.CLIENT c
LEFT JOIN company_2025.CLIENT_ADDRESS ca
ON ca.CLIENT_ID = c.CLIENT_ID
GROUP BY c.CLIENT_ID, c.SHORT_NAME;

#Miasta i unikalne dwuznakowe prefixy kodów pocztowych (pierwsze 2 znaki) po przecinku w jednej kolumnie.

SELECT
CITY,
GROUP_CONCAT(
DISTINCT SUBSTR(POSTAL_CODE, 1, 2)
ORDER BY SUBSTR(POSTAL_CODE, 1, 2)
SEPARATOR ', '
) AS postal_prefixes
FROM company_2025.CLIENT_ADDRESS
GROUP BY CITY;

#Wyświetl dla każdego pracownika połączone nazwisko i imię dodatkowo dział oraz liczbę dnia od zatrudnienia.

SELECT
CONCAT(e.LAST_NAME, ' ', e.FIRST_NAME) AS pracownik,
d.DEPARTMENT_NAME,
DATEDIFF(CURDATE(), e.DATE_OF_EMPLOYMENT) AS dni_od_zatrudnienia
FROM company_2025.EMPLOYEE e
LEFT JOIN company_2025.DEPARTMENT d
ON d.DEPARTMENT_ID = e.DEPARTMENT_ID;

#Dla każdego klienta wyświetl dwie kolumny:
#Pierwsza kolumna zawiera pełną nazwę klienta oraz nazwę skróconą po myślniku (np. "Food Market SA' - FoodMarket"),
#Druga kolumna zawiera listę trzech ostatnich cyfr wszystkich numerów zamówień, które złożył klient, oddzielonych przecinkami, w formacie (np. "003, 005, 123").

SELECT
CONCAT(c.FULL_NAME, ' - ', c.SHORT_NAME) AS klient,
GROUP_CONCAT(
RIGHT(o.ORDER_NUMBER, 3)
ORDER BY o.ORDER_DATE
SEPARATOR ', '
) AS last3_order_numbers
FROM company_2025.CLIENT c
LEFT JOIN company_2025.`ORDER` o
ON o.CLIENT_ID = c.CLIENT_ID
GROUP BY c.CLIENT_ID, c.FULL_NAME, c.SHORT_NAME;

#Dla każdego pracownika stwórz i wyświetl hasło, które będzie składać się z
#pierwszych 3 liter imienia (małymi literami),
#a następnie ostatnich 4 znaków nazwiska (wielkimi literami),
#a na koniec suma długości imienia i nazwy jego ulicy (liczba znaków).
#Hasło powinno wyglądać np. tak  abcWXYZ7, gdzie abc to trzy pierwsze litery imienia małymi literami, WXYZ to ostatnie cztery litery nazwiska wielkimi literami, a 7 to suma długości imienia i nazwy jego ulicy.

SELECT
e.FIRST_NAME,
e.LAST_NAME,
CONCAT(
LOWER(LEFT(e.FIRST_NAME, 3)),
UPPER(RIGHT(e.LAST_NAME, 4)),
(
LENGTH(e.FIRST_NAME)
+ LENGTH(YEAR(e.BIRTH_DATE))
+ LENGTH(MONTH(e.BIRTH_DATE))
+ LENGTH(DAY(e.BIRTH_DATE))
)
) AS haslo
FROM company_2025.EMPLOYEE e;

#Zadanie 4
#Wykorzystując funkcję DATE_FORMAT (dokumentacja) wyświetl datę sprzedaży zamówienia w postaci:
#dzień-miesiąc-rok,
#rok - tydzień roku,
#rok - dzień roku,
#angielska nazwa miesiąca/dzień/rok.

SELECT
o.ORDER_ID,
o.ORDER_DATE,
DATE_FORMAT(o.ORDER_DATE, '%d-%m-%Y') AS dzien_miesiac_rok,
DATE_FORMAT(o.ORDER_DATE, '%x-%v')    AS rok_tydzien_roku,
DATE_FORMAT(o.ORDER_DATE, '%Y-%j')    AS rok_dzien_roku,
DATE_FORMAT(o.ORDER_DATE, '%M/%d/%Y') AS month_name_day_year_en
FROM company_2025.`ORDER` o;

#Przygotuj zapytanie SQL, które odpowie na pytanie: W którym tygodniu 2025 roku złożono zamówienia o największej łącznej wartości?

SELECT
DATE_FORMAT(o.ORDER_DATE, '%x-%v') AS rok_tydzien,
SUM(op.AMOUNT * op.SELL_PRICE) AS laczna_wartosc
FROM company_2025.`ORDER` o
JOIN company_2025.ORDER_POSITION op
ON op.ORDER_ID = o.ORDER_ID
WHERE YEAR(o.ORDER_DATE) = 2025
GROUP BY DATE_FORMAT(o.ORDER_DATE, '%x-%v')
ORDER BY laczna_wartosc DESC
LIMIT 1;
